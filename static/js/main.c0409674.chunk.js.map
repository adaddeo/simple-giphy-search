{"version":3,"sources":["../node_modules/@giphy/js-brand/dist sync","giphy.ts","state/ducks/gifs.ts","state/ducks/search.ts","state/ducks/viewer.ts","state/selectors.ts","components/hooks/useBricks.ts","components/hooks/useClientRect.ts","components/hooks/useIntersectionObserver.ts","components/FullscreenViewer.tsx","components/Loader.tsx","components/Gifs.tsx","components/App.tsx","state/reducer.ts","state/createStore.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","gf","GiphyFetch","fetchGifs","retry","dispatch","getState","state","query","search","gifs","offset","payload","Promise","reject","a","request","giphy","trending","response","type","catch","getEmptyState","pendingRequests","UPDATE_QUERY","CLOSE","isLoadingSelector","createSelector","moreGifsSelector","totalCount","undefined","viewGifSelector","viewer","gifIndex","index","bricksOptions","key","dependencies","container","useRef","instance","keyRef","useEffect","current","Bricks","resize","pack","update","ref","currentSize","getCurrentSize","sizes","reduce","size","option","window","matchMedia","mq","matches","target","useState","rect","setRect","handleResize","useCallback","getBoundingClientRect","node","addEventListener","removeEventListener","element","onVisiblilityChange","threshold","rootMargin","observer","IntersectionObserver","entry","isIntersecting","observe","disconnect","mapDispatchToProps","close","connect","gif","useClientRect","document","documentElement","style","overflow","body","overflowY","handler","handleClose","event","stopPropagation","preventDefault","width","original","images","maxWidth","Math","min","height","className","onClick","backgroundColor","onGifClick","g","loader","fetchGifsAction","openGif","isLoading","moreGifs","props","useBricks","packed","columns","gutter","bricksContainer","gifWidth","contentContainer","floor","loaderContainer","useIntersectionObserver","visible","map","idx","handleGifClick","length","updateQuery","setQuery","onSubmit","placeholder","value","onChange","reducers","action","data","pagination","gifIds","acc","filter","max","count","total_count","reducer","combineReducers","middleware","createLogger","promise","thunk","rootElement","getElementById","store","reduxCreateStore","applyMiddleware","ReactDOM","render"],"mappings":"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","file":"static/js/main.c0409674.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 60;","import { GiphyFetch } from '@giphy/js-fetch-api'\n\nconst API_KEY = '5yFUiFNdRnPjpeUhzS2T2LGyw1Fi9ClD'\nconst gf = new GiphyFetch(API_KEY)\n\nexport default gf\n","import { GifsResult as GiphyResult } from '@giphy/js-fetch-api'\nimport { IGif } from '@giphy/js-types'\nimport { AsyncAction } from 'redux-promise-middleware'\nimport giphy from '../../giphy'\nimport { ThunkDispatch, ThunkGetState, ThunkResult } from '../index'\nimport { RootAction } from '../index'\nimport { UPDATE_QUERY } from './search'\n\n// State\n\nexport interface GifsState {\n  id: number\n  gifs: IGif[]\n  pendingRequests: number\n  offset: number\n  totalCount?: number\n}\n\nexport const updateStateFromGiphyResult =\n  (state: GifsState, result: GiphyResult) => {\n    const { data, pagination } = result\n\n    return {\n      ...state,\n      gifs: [...state.gifs, ...data],\n      offset: pagination.offset + pagination.count,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n// Actions\n\nexport const FETCH = 'gifs/FETCH'\nexport const FETCH_PENDING = 'gifs/FETCH_PENDING'\nexport const FETCH_FUFILLED = 'gifs/FETCH_FULFILLED'\nexport const FETCH_REJECTED = 'gifs/FETCH_REJECTED'\n\ninterface FetchResult {\n  id: number\n  response: GiphyResult\n}\n\nexport interface FetchAction extends AsyncAction {\n  type: typeof FETCH\n  payload: Promise<FetchResult>\n}\n\nexport interface FetchPendingAction {\n  type: typeof FETCH_PENDING\n}\n\nexport interface FetchFulfilledAction {\n  type: typeof FETCH_FUFILLED\n  payload: FetchResult\n}\n\nexport type GifsAction =\n  | FetchAction\n  | FetchPendingAction\n  | FetchFulfilledAction\n\n// Action Creators\n\nexport const fetchGifs = (retry: boolean = true): ThunkResult<FetchAction> => {\n  return (dispatch: ThunkDispatch, getState: ThunkGetState) => {\n    const state = getState()\n    const { query } = state.search\n    const { id, offset } = state.gifs\n\n    const payload = new Promise<FetchResult>(async (resolve, reject) => {\n      const request = query === '' ? giphy.trending({ offset }) : giphy.search(query, { offset })\n      try {\n        const response = await request\n\n        resolve({ id, response })\n      } catch (e) {\n        reject(e)\n      }\n    })\n\n    // @ts-ignore the redux-promise-middleware will transform this to a promise\n    return dispatch({\n      type: FETCH,\n      payload\n    }).catch(() => {\n      // Retry once\n      if (retry) {\n        return dispatch(fetchGifs(false))\n      } else {\n        return Promise.resolve()\n      }\n    })\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (id: number = 0): GifsState => ({\n  id,\n  gifs: [],\n  pendingRequests: 0,\n  offset: 0\n})\n\nexport const reducer = (\n  state: GifsState = getEmptyState(),\n  action: RootAction\n): GifsState => {\n  if (action.type === FETCH_PENDING) {\n    return {\n      ...state,\n      pendingRequests: state.pendingRequests + 1\n    }\n  }\n\n  if (action.type === FETCH_FUFILLED) {\n    const { id, response } = action.payload\n\n    // Ignore the request if it's from a previous search\n    if (state.id !== id) {\n      return state\n    }\n\n    const { data, pagination } = response\n\n    // Ignore if we have no data (example searching ~!@#$%^&() seems to break the Giphy\n    // api and return a strange 200 but with an error message and no data)\n    if (data.length === 0 && pagination === undefined) {\n      return state\n    }\n\n    // This de-dupe method could be made more efficient by storing ids in a Map in state\n    const gifIds = state.gifs.reduce(\n      (acc: any, g) => {\n        acc[g.id] = true\n        return acc;\n      },\n    {})\n\n    // Only add gifs that aren't already in state\n    const gifs = [...state.gifs, ...data.filter((g: IGif) => gifIds[g.id] === undefined)]\n\n    // Account for the possibility that requests come back out-of-order\n    const offset = Math.max(state.offset, pagination.offset + pagination.count)\n\n    return {\n      ...state,\n      gifs,\n      offset,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n  if (action.type === UPDATE_QUERY) {\n    return getEmptyState(state.id + 1)\n  }\n\n  return state\n}\n","import { RootAction } from '../'\nimport { ThunkDispatch, ThunkResult } from '../index'\nimport { fetchGifs } from './gifs'\n\n// State\n\nexport interface SearchState {\n  query: string\n}\n\n// Actions\n\nexport const UPDATE_QUERY = 'search/UPDATE_QUERY'\n\nexport interface UpdateQueryAction {\n  type: typeof UPDATE_QUERY\n  payload: {\n    query: string\n  }\n}\n\nexport type SearchAction = UpdateQueryAction\n\n// Action Creators\n\nconst updateQuery = (query: string): UpdateQueryAction => {\n  return {\n    type: UPDATE_QUERY,\n    payload: {\n      query\n    }\n  }\n}\n\nexport const search = (query: string): ThunkResult<void> => {\n  return (dispatch: ThunkDispatch) => {\n    dispatch(updateQuery(query))\n    dispatch(fetchGifs())\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (): SearchState => ({\n  query: ''\n})\n\nexport const reducer = (\n  state: SearchState = getEmptyState(),\n  action: RootAction\n): SearchState => {\n  if (action.type === UPDATE_QUERY) {\n    const { query } = action.payload\n\n    return { query }\n  }\n\n  return state\n}\n","import { RootAction } from '../'\n\n// State\n\nexport interface ViewerState {\n  gifIndex: number | null\n}\n\n// Actions\n\nexport const CLOSE    = 'viewer/CLOSE'\nexport const OPEN_GIF = 'viewer/OPEN_GIF'\n\nexport interface CloseAction {\n  type: typeof CLOSE\n}\n\nexport interface OpenGifAction {\n  type: typeof OPEN_GIF\n  payload: {\n    gifIndex: number\n  }\n}\n\nexport type ViewerAction =\n  | CloseAction\n  | OpenGifAction\n\n// Action Creators\n\nexport const close = (): CloseAction => {\n  return {\n    type: CLOSE\n  }\n}\n\nexport const openGif = (gifIndex: number): OpenGifAction => {\n  return {\n    type: OPEN_GIF,\n    payload: {\n      gifIndex\n    }\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (): ViewerState => ({\n  gifIndex: null\n})\n\nexport const reducer = (\n  state: ViewerState = getEmptyState(),\n  action: RootAction\n): ViewerState => {\n  if (action.type === CLOSE) {\n    return getEmptyState()\n  }\n\n  if (action.type === OPEN_GIF) {\n    const { gifIndex } = action.payload\n\n    return {\n      gifIndex\n    }\n  }\n\n  return state\n}\n","import { IGif } from '@giphy/js-types'\nimport { createSelector } from 'reselect'\nimport { RootState } from './'\n\nexport const isLoadingSelector = createSelector<RootState, number, boolean>(\n  state => state.gifs.pendingRequests,\n  pendingRequests => pendingRequests > 0\n)\n\nexport const moreGifsSelector = createSelector<RootState, number, number | undefined, boolean>(\n  state => state.gifs.offset,\n  state => state.gifs.totalCount,\n  (offset, totalCount) => totalCount === undefined || offset < totalCount\n)\n\nexport const viewGifSelector = createSelector <RootState, number | null, IGif[], IGif | null>(\n  state => state.viewer.gifIndex,\n  state => state.gifs.gifs,\n  (index, gifs) => index !== null ? gifs[index] : null\n)\n","import Bricks, { BricksInstance, BricksOptions, SizeDetail } from 'bricks.js'\nimport { RefObject, useEffect, useRef } from 'react'\n\nexport default (\n  bricksOptions: Omit<BricksOptions, 'container'>,\n  key: string = '',\n  dependencies: any[] = []\n): {\n  ref: RefObject<HTMLDivElement>,\n  currentSize: SizeDetail\n} => {\n  const container = useRef<HTMLDivElement | null>(null)\n  const instance = useRef<BricksInstance | null>(null)\n  const keyRef = useRef<string>(key)\n\n  useEffect(\n    () => {\n\n      // A new Bricks.js will be instantiated when one doesn't exist or the key changes.\n      if (container.current !== null && (instance.current === null || keyRef.current !== key)) {\n        instance.current = Bricks({\n          ...bricksOptions,\n          container: container.current,\n        })\n\n        instance.current\n          .resize(true)\n          .pack()\n\n        keyRef.current = key\n      }\n\n      if (instance.current !== null) {\n        // At this point we are calling the more efficient update with the assumption that\n        // already packed gifs haven't been removed or modified\n        instance.current.update()\n      }\n    },\n\n    // Disable linting to support additional dependencies. Note: brickOptions aren't\n    // included and thus can't be dynamically set.\n    // eslint-disable-next-line\n    [container, ...dependencies]\n  )\n\n  return { ref: container, currentSize: getCurrentSize(bricksOptions.sizes) }\n}\n\n/*\n * Helper function to help us dynamically size our gifs based on the current window size\n * and number of columns and gutter widths currently being used. Currently relies on sizes\n * being ordered from smallest to largest media query, with default as the first element.\n */\nfunction getCurrentSize(sizes: SizeDetail[]): { gutter: number, columns: number} {\n  return sizes.reduce(\n    (size, option) => {\n      return window.matchMedia(`(min-width: ${option.mq})`).matches ? option : size\n    }\n  )\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\n\nexport default (): [ClientRect | null, (node: HTMLElement | null) => void] => {\n  const target = useRef<HTMLElement | null>(null)\n  const [rect, setRect] = useState<ClientRect | null>(null)\n\n  const handleResize = useCallback(() => {\n    if (target.current !== null) {\n      setRect(target.current.getBoundingClientRect())\n    }\n  }, [target])\n\n  const ref = useCallback(node => {\n    if (node !== null) {\n      target.current = node\n      handleResize()\n    }\n  }, [handleResize])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize)\n    return () => {\n      window.removeEventListener('resize', handleResize)\n    }\n  })\n\n  return [rect, ref]\n}\n","import { useEffect } from 'react'\n\nexport interface UseObserverOptions {\n  element: HTMLDivElement | null\n  onVisiblilityChange: (isVisible: boolean) => void,\n  threshold?: number,\n  rootMargin?: string\n}\n\nexport default ({\n  element,\n  onVisiblilityChange,\n  threshold = 0,\n  rootMargin = '0px'\n}: UseObserverOptions) => {\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]: IntersectionObserverEntry[]) => {\n      onVisiblilityChange(entry.isIntersecting)\n    }, { threshold, rootMargin })\n\n    if (element !== null) {\n      observer.observe(element)\n    }\n\n    return () => {\n      if (element !== null) {\n        observer.disconnect()\n      }\n    }\n  })\n}\n","import { IGif } from '@giphy/js-types'\nimport { Gif } from '@giphy/react-components'\nimport React, { MouseEvent, SyntheticEvent, useEffect } from 'react'\nimport { connect } from 'react-redux'\nimport { RootState } from '../state'\nimport { close as closeAction } from '../state/ducks/viewer'\nimport { viewGifSelector } from '../state/selectors'\nimport './FullscreenViewer.css'\nimport { useClientRect } from './hooks'\n\ninterface Props {\n  gif: IGif | null\n  close: () => void\n}\n\nexport function FullscreenViewer({ gif, close }: Props) {\n\n  // We will use the client rectangle of our viewer to determine maximum gif width\n  const [rect, ref] = useClientRect()\n\n  // Prevent scrolling when viewer is open\n  useEffect(() => {\n    document.documentElement.style.overflow = gif !== null ? 'hidden' : null\n    document.body.style.overflowY = gif !== null ? 'scroll' : null\n\n    return () => {\n      document.documentElement.style.overflow = null\n      document.body.style.overflowY = null\n    }\n  }, [gif])\n\n  // Add hotkey for closing with esc\n  useEffect(() => {\n    function handler(e: any) {\n      if (e.key === 'Escape') {\n        close()\n      }\n    }\n\n    window.addEventListener('keydown', handler)\n\n    return () => {\n      window.removeEventListener('keydown', handler)\n    }\n  }, [close])\n\n  const handleClose = (event: MouseEvent | SyntheticEvent) => {\n    close()\n    event.stopPropagation()\n    event.preventDefault()\n  }\n\n  if (gif === null) {\n    return null\n  }\n\n  let width = 600\n\n  // Fit using a \"contain\" model, maximizing the size while keep both the height and\n  // width in bounds.\n  if (rect !== null) {\n    const { original } = gif.images\n    // Don't warp the gif more than 2x\n    const maxWidth = Math.min(original.width * 2, rect.width)\n\n    if (original.height / original.width * maxWidth > rect.height) {\n      width = rect.height * original.width / original.height\n    } else {\n      width = maxWidth\n    }\n  }\n\n  return (\n    <div className=\"fullscreen-viewer\" onClick={handleClose}>\n      <div ref={ref} className=\"fullscreen-viewer-content\">\n        <Gif\n          gif={gif}\n          width={width}\n          backgroundColor=\"black\"\n          onGifClick={(g, e) => handleClose(e) }\n        />\n      </div>\n    </div>\n  )\n}\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    gif: viewGifSelector(state)\n  }\n}\n\nconst mapDispatchToProps = {\n  close: closeAction\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(FullscreenViewer)\n","import React from 'react'\nimport './Loader.css'\n\nconst loader = () =>\n  <div className=\"lds-ellipsis\">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n  </div>\n\nexport default loader\n","import { IGif } from '@giphy/js-types'\nimport { Gif } from '@giphy/react-components'\nimport React, { SyntheticEvent, useEffect, useRef } from 'react'\nimport { connect } from 'react-redux'\nimport { RootState } from '../state'\nimport { fetchGifs as fetchGifsAction } from '../state/ducks/gifs'\nimport { openGif as openGifAction } from '../state/ducks/viewer'\nimport { isLoadingSelector, moreGifsSelector } from '../state/selectors'\nimport './Gifs.css'\nimport { useBricks, useClientRect, useIntersectionObserver } from './hooks'\nimport Loader from './Loader'\n\ninterface Props {\n  query: string\n  gifs: IGif[]\n  isLoading: boolean\n  moreGifs: boolean\n  fetchGifs: () => void\n  openGif: (idx: number) => void\n}\n\nexport function Gifs(props: Props) {\n  const { query, gifs, isLoading, moreGifs, fetchGifs, openGif } = props\n\n  // Initial load of trending gifs\n  useEffect(() => { fetchGifs() }, [fetchGifs])\n\n  const handleGifClick = (idx: number, event: SyntheticEvent<HTMLElement, Event>) => {\n    openGif(idx)\n    event.stopPropagation()\n    event.preventDefault()\n  }\n\n  // This ref will hold the DOM node of the gif container for use by Bricks.js\n  const { ref: bricksContainer, currentSize: { gutter, columns } } = useBricks(\n    {\n      packed: 'packed',\n      sizes: [\n        { columns: 2, gutter: 8 },\n        { mq: '768px', columns: 3, gutter: 12 },\n        { mq: '1024px', columns: 4, gutter: 16 },\n        { mq: '1260px', columns: 4, gutter: 16 }\n      ]\n    },\n    query,\n    [gifs]\n  )\n\n  // Calculate the width each gif should be based on the width of the container and the\n  // number of columns and gutter width at the current viewport size\n  let gifWidth = 200\n  const [rect, contentContainer] = useClientRect()\n\n  if (rect !== null) {\n    gifWidth = Math.floor((rect.width - gutter * (columns - 1)) / columns)\n  }\n\n  // Setup observed div at the end of gifs to detect when we should attempt to load\n  // the next page\n  const loaderContainer = useRef<HTMLDivElement>(null)\n\n  const handleVisibilityChange = (visible: boolean) => {\n    if (visible && !isLoading && moreGifs) {\n      fetchGifs()\n    }\n  }\n\n  useIntersectionObserver({\n    element: loaderContainer.current,\n    onVisiblilityChange: handleVisibilityChange,\n    rootMargin: '200px'\n  })\n\n  return (\n    <div ref={contentContainer}>\n      <div ref={bricksContainer} key={query} className=\"gifs-container\">\n        { gifs.map(\n            (gif, idx) =>\n              <Gif\n                key={gif.id}\n                gif={gif}\n                width={gifWidth}\n                backgroundColor=\"#e8f4fd\"\n                onGifClick={(g, e) => handleGifClick(idx, e)}\n              />\n        )}\n      </div>\n\n      { !isLoading && gifs.length === 0 &&\n        <div className=\"info\">\n          No gifs found for <b>{query}</b>\n        </div>\n      }\n\n      { moreGifs &&\n        <div ref={loaderContainer} className=\"loader-container\">\n          { isLoading && <Loader /> }\n        </div>\n      }\n      { !moreGifs && gifs.length > 0 &&\n        <div className=\"info\">\n          No more gifs.\n        </div>\n      }\n    </div>\n  )\n}\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    query: state.search.query,\n    gifs: state.gifs.gifs,\n    isLoading: isLoadingSelector(state),\n    moreGifs: moreGifsSelector(state)\n  }\n}\n\nconst mapDispatchToProps = {\n  fetchGifs: fetchGifsAction,\n  openGif: openGifAction\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Gifs)\n","import React, { useState } from 'react'\nimport { connect } from 'react-redux'\nimport { search as searchAction } from '../state/ducks/search'\nimport './App.css'\nimport FullscreenViewer from './FullscreenViewer'\nimport Gifs from './Gifs'\n\ninterface Props {\n  search: (q: string) => void\n}\n\nexport function App({ search }: Props) {\n  const [query, setQuery] = useState('')\n\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\n    setQuery(event.target.value)\n  }\n\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    search(query)\n    event.preventDefault()\n  }\n\n  return (\n    <div className=\"app container\">\n      <nav className=\"header\">\n        <div className=\"header-content container\">\n          <form onSubmit={handleSubmit}>\n            <input\n              type=\"text\"\n              placeholder=\"Search for GIFs\"\n              value={query}\n              onChange={handleInputChange}\n            />\n          </form>\n        </div>\n      </nav>\n      <div className=\"main\">\n        <Gifs />\n        <FullscreenViewer />\n      </div>\n    </div>\n  )\n}\n\nconst mapDispatchToProps = {\n  search: searchAction\n}\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(App)\n","import { combineReducers } from 'redux'\nimport { reducer as gifs } from './ducks/gifs'\nimport { reducer as search } from './ducks/search'\nimport { reducer as viewer } from './ducks/viewer'\nimport { RootAction, RootState } from './index'\n\nexport const reducers = {\n  search,\n  gifs,\n  viewer\n}\n\nexport const reducer = combineReducers<RootState, RootAction>(reducers)\n","import { applyMiddleware, createStore as reduxCreateStore } from 'redux'\nimport { createLogger } from 'redux-logger'\nimport promise from 'redux-promise-middleware'\nimport thunk from 'redux-thunk'\n\nimport { reducer } from './reducer'\n\nconst logger = createLogger()\n\nconst middleware = [promise, thunk]\n\nif (process.env.NODE_ENV !== 'production') {\n  middleware.push(logger)\n}\n\nexport const createStore = () => reduxCreateStore(reducer, applyMiddleware(...middleware))\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport App from './components/App'\nimport { createStore } from './state/createStore'\n\nconst rootElement = document.getElementById('root')\nconst store = createStore()\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n)\n"],"sourceRoot":""}