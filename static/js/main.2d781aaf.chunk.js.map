{"version":3,"sources":["../node_modules/@giphy/js-brand/dist sync","giphy.ts","state/ducks/gifs.ts","state/ducks/search.ts","state/selectors.ts","components/hooks/useBricks.ts","components/hooks/useClientRect.ts","components/hooks/useIntersectionObserver.ts","components/Loader.tsx","components/Gifs.tsx","components/App.tsx","state/reducer.ts","state/createStore.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","gf","GiphyFetch","fetchGifs","dispatch","getState","state","query","search","gifs","offset","type","payload","Promise","a","request","giphy","trending","response","getEmptyState","pendingRequests","UPDATE_QUERY","isLoadingSelector","createSelector","moreGifsSelector","totalCount","undefined","bricksOptions","key","dependencies","container","useRef","instance","keyRef","useEffect","current","Bricks","resize","pack","update","ref","currentSize","getCurrentSize","sizes","reduce","size","option","window","matchMedia","mq","matches","target","useState","rect","setRect","handleResize","useCallback","getBoundingClientRect","node","addEventListener","removeEventListener","element","onVisiblilityChange","threshold","rootMargin","observer","IntersectionObserver","entry","isIntersecting","observe","disconnect","loader","className","connect","isLoading","moreGifs","fetchGifsAction","props","useBricks","packed","columns","gutter","bricksContainer","gifWidth","useClientRect","Math","floor","width","loaderContainer","useIntersectionObserver","visible","map","gif","backgroundColor","mapDispatchToProps","updateQuery","setQuery","onSubmit","event","preventDefault","placeholder","value","onChange","reducers","action","data","pagination","max","count","total_count","reducer","combineReducers","middleware","createLogger","promise","thunk","rootElement","document","getElementById","store","reduxCreateStore","applyMiddleware","ReactDOM","render"],"mappings":"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","file":"static/js/main.2d781aaf.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 60;","import { GiphyFetch } from '@giphy/js-fetch-api'\n\nconst API_KEY = '5yFUiFNdRnPjpeUhzS2T2LGyw1Fi9ClD'\nconst gf = new GiphyFetch(API_KEY)\n\nexport default gf\n","import { GifsResult as GiphyResult } from '@giphy/js-fetch-api'\nimport { IGif } from '@giphy/js-types'\nimport giphy from '../../giphy'\nimport { ThunkDispatch, ThunkGetState, ThunkResult } from '../index'\nimport { RootAction } from '../index'\nimport { UPDATE_QUERY } from './search'\n\n// State\n\nexport interface GifsState {\n  id: number\n  gifs: IGif[]\n  pendingRequests: number\n  offset: number\n  totalCount?: number\n}\n\nexport const updateStateFromGiphyResult =\n  (state: GifsState, result: GiphyResult) => {\n    const { data, pagination } = result\n\n    return {\n      ...state,\n      gifs: [...state.gifs, ...data],\n      offset: pagination.offset + pagination.count,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n// Actions\n\nexport const FETCH = 'gifs/FETCH'\nexport const FETCH_PENDING = 'gifs/FETCH_PENDING'\nexport const FETCH_FUFILLED = 'gifs/FETCH_FULFILLED'\n\ninterface FetchResult {\n  id: number\n  response: GiphyResult\n}\n\nexport interface FetchAction {\n  type: typeof FETCH\n  payload: Promise<FetchResult>\n}\n\nexport interface FetchPendingAction {\n  type: typeof FETCH_PENDING\n}\n\nexport interface FetchFulfilledAction {\n  type: typeof FETCH_FUFILLED\n  payload: FetchResult\n}\n\nexport type GifsAction =\n  | FetchAction\n  | FetchPendingAction\n  | FetchFulfilledAction\n\n// Action Creators\n\nexport const fetchGifs = (): ThunkResult<FetchAction> => {\n  return (dispatch: ThunkDispatch, getState: ThunkGetState) => {\n    const state = getState()\n    const { query } = state.search\n    const { id, offset } = state.gifs\n\n    const payload = new Promise<FetchResult>(async (resolve) => {\n      const request = query === '' ? giphy.trending({ offset }) : giphy.search(query, { offset })\n      const response = await request\n\n      resolve({ id, response })\n    })\n\n    return dispatch({\n      type: FETCH,\n      payload\n    })\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (id: number = 0) => ({\n  id,\n  gifs: [],\n  pendingRequests: 0,\n  offset: 0\n})\n\nexport const reducer = (\n  state: GifsState = getEmptyState(),\n  action: RootAction\n): GifsState => {\n  if (action.type === FETCH_PENDING) {\n    return {\n      ...state,\n      pendingRequests: state.pendingRequests + 1\n    }\n  }\n\n  if (action.type === FETCH_FUFILLED) {\n    const { id, response } = action.payload\n\n    // Ignore the request if it's from a previous search\n    if (state.id !== id) {\n      return state\n    }\n\n    const { data, pagination } = response\n\n    const gifs = [...state.gifs, ...data]\n    // Account for the possibility that requests come back out-of-order\n    const offset = Math.max(state.offset, pagination.offset + pagination.count)\n\n    return {\n      ...state,\n      gifs,\n      offset,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n  if (action.type === UPDATE_QUERY) {\n    return getEmptyState(state.id + 1)\n  }\n\n  return state\n}\n","import { ThunkDispatch, ThunkResult } from '../index'\nimport { RootAction } from '../index'\nimport { fetchGifs } from './gifs'\n\n// State\n\nexport interface SearchState {\n  query: string\n}\n\n// Actions\n\nexport const UPDATE_QUERY = 'search/UPDATE_QUERY'\n\nexport interface UpdateQueryAction {\n  type: typeof UPDATE_QUERY\n  payload: {\n    query: string\n  }\n}\n\nexport type SearchAction = UpdateQueryAction\n\n// Action Creators\n\nconst updateQuery = (query: string): UpdateQueryAction => {\n  return {\n    type: UPDATE_QUERY,\n    payload: {\n      query\n    }\n  }\n}\n\nexport const search = (query: string): ThunkResult<void> => {\n  return (dispatch: ThunkDispatch) => {\n    dispatch(updateQuery(query))\n    dispatch(fetchGifs())\n  }\n}\n\n// Reducer\n\nexport const reducer = (\n  state: SearchState = { query: '' },\n  action: RootAction\n): SearchState => {\n  if (action.type === UPDATE_QUERY) {\n    const { query } = action.payload\n\n    return { query }\n  }\n\n  return state\n}\n","import { createSelector } from 'reselect'\nimport { RootState } from './index'\n\nexport const isLoadingSelector = createSelector<RootState, number, boolean>(\n  state => state.gifs.pendingRequests,\n  pendingRequests => pendingRequests > 0\n)\n\nexport const moreGifsSelector = createSelector<RootState, number, number | undefined, boolean>(\n  state => state.gifs.offset,\n  state => state.gifs.totalCount,\n  (offset, totalCount) => totalCount === undefined || offset < totalCount\n)\n","import Bricks, { BricksInstance, BricksOptions, SizeDetail } from 'bricks.js'\nimport { RefObject, useEffect, useRef } from 'react'\n\nexport default (\n  bricksOptions: Omit<BricksOptions, 'container'>,\n  key: string = '',\n  dependencies: any[] = []\n): {\n  ref: RefObject<HTMLDivElement>,\n  currentSize: SizeDetail\n} => {\n  const container = useRef<HTMLDivElement | null>(null)\n  const instance = useRef<BricksInstance | null>(null)\n  const keyRef = useRef<string>(key)\n\n  useEffect(\n    () => {\n\n      // A new Bricks.js will be instantiated when one doesn't exist or the key changes.\n      if (container.current !== null && (instance.current === null || keyRef.current !== key)) {\n        instance.current = Bricks({\n          ...bricksOptions,\n          container: container.current,\n        })\n\n        instance.current\n          .resize(true)\n          .pack()\n\n        keyRef.current = key\n      }\n\n      if (instance.current !== null) {\n        // At this point we are calling the more efficient update with the assumption that\n        // already packed gifs haven't been removed or modified\n        instance.current.update()\n      }\n    },\n\n    // Disable linting to support additional dependencies. Note: brickOptions aren't\n    // included and thus can't be dynamically set.\n    // eslint-disable-next-line\n    [container, ...dependencies]\n  )\n\n  return { ref: container, currentSize: getCurrentSize(bricksOptions.sizes) }\n}\n\n/*\n * Helper function to help us dynamically size our gifs based on the current window size\n * and number of columns and gutter widths currently being used. Currently relies on sizes\n * being ordered from smallest to largest media query, with default as the first element.\n */\nfunction getCurrentSize(sizes: SizeDetail[]): { gutter: number, columns: number} {\n  return sizes.reduce(\n    (size, option) => {\n      return window.matchMedia(`(min-width: ${option.mq})`).matches ? option : size\n    }\n  )\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\n\nexport default (): [ClientRect | null, (node: HTMLElement | null) => void] => {\n  const target = useRef<HTMLElement | null>(null)\n  const [rect, setRect] = useState<ClientRect | null>(null)\n\n  const handleResize = useCallback(() => {\n    if (target.current !== null) {\n      setRect(target.current.getBoundingClientRect())\n    }\n  }, [target])\n\n  const ref = useCallback(node => {\n    if (node !== null) {\n      target.current = node\n      handleResize()\n    }\n  }, [handleResize])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize)\n    return () => {\n      window.removeEventListener('resize', handleResize)\n    }\n  })\n\n  return [rect, ref]\n}\n","import { useEffect } from 'react'\n\nexport interface UseObserverOptions {\n  element: HTMLDivElement | null\n  onVisiblilityChange: (isVisible: boolean) => void,\n  threshold?: number,\n  rootMargin?: string\n}\n\nexport default ({\n  element,\n  onVisiblilityChange,\n  threshold = 0,\n  rootMargin = '0px'\n}: UseObserverOptions) => {\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]: IntersectionObserverEntry[]) => {\n      onVisiblilityChange(entry.isIntersecting)\n    }, { threshold, rootMargin })\n\n    if (element !== null) {\n      observer.observe(element)\n    }\n\n    return () => {\n      if (element !== null) {\n        observer.disconnect()\n      }\n    }\n  })\n}\n","import React from 'react'\nimport './Loader.css'\n\nconst loader = () =>\n  <div className=\"lds-ellipsis\">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n  </div>\n\nexport default loader\n","import { IGif } from '@giphy/js-types'\nimport { Gif } from '@giphy/react-components'\nimport React, { useRef } from 'react'\nimport { connect } from 'react-redux'\nimport { RootState } from '../state'\nimport { fetchGifs as fetchGifsAction } from '../state/ducks/gifs'\nimport { isLoadingSelector, moreGifsSelector } from '../state/selectors'\nimport './Gifs.css'\nimport useBricks from './hooks/useBricks'\nimport useClientRect from './hooks/useClientRect'\nimport useIntersectionObserver from './hooks/useIntersectionObserver'\nimport Loader from './Loader'\n\ninterface Props {\n  query: string\n  gifs: IGif[]\n  isLoading: boolean\n  moreGifs: boolean\n  fetchGifs: () => void\n}\n\nfunction Gifs(props: Props) {\n  const { query, gifs, isLoading, moreGifs, fetchGifs } = props\n\n  // This ref will hold the DOM node of the gif container for use by Bricks.js\n  const { ref: bricksContainer, currentSize: { gutter, columns } } = useBricks(\n    {\n      packed: 'packed',\n      sizes: [\n        { columns: 2, gutter: 8 },\n        { mq: '768px', columns: 3, gutter: 12 },\n        { mq: '1024px', columns: 4, gutter: 16 },\n        { mq: '1260px', columns: 4, gutter: 16 }\n      ]\n    },\n    query,\n    [gifs]\n  )\n\n  // useEffect(() => {\n  //   console.log('effect ran')\n  // }, [bricksOptions.current])\n\n  // Calculate the width each gif should be based on the width of the container and the\n  // number of columns and gutter width at the current viewport size\n  let gifWidth = 200\n  const [rect, ref] = useClientRect()\n\n  if (rect !== null) {\n    gifWidth = Math.floor((rect.width - gutter * (columns - 1)) / columns)\n  }\n\n  // Setup observed div at the end of gifs to detect when we should attempt to load\n  // the next page\n  const loaderContainer = useRef<HTMLDivElement>(null)\n\n  const handleVisibilityChange = (visible: boolean) => {\n    if (visible && !isLoading && moreGifs) {\n      fetchGifs()\n    }\n  }\n\n  useIntersectionObserver({\n    element: loaderContainer.current,\n    onVisiblilityChange: handleVisibilityChange,\n    rootMargin: '200px'\n  })\n\n  return (\n    <div ref={ref}>\n      <div ref={bricksContainer} key={query}>\n        { gifs.map(\n            gif =>\n              <Gif\n                key={gif.id}\n                gif={gif}\n                width={gifWidth}\n                backgroundColor=\"#e8f4fd\"\n              />\n        )}\n      </div>\n\n      { moreGifs &&\n        <div ref={loaderContainer} className=\"loader-container\">\n          { isLoading && <Loader /> }\n        </div>\n      }\n    </div>\n  )\n}\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    query: state.search.query,\n    gifs: state.gifs.gifs,\n    isLoading: isLoadingSelector(state),\n    moreGifs: moreGifsSelector(state)\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  { fetchGifs: fetchGifsAction }\n)(Gifs)\n","import React, { useState } from 'react'\nimport { connect } from 'react-redux'\nimport { search as searchAction } from '../state/ducks/search'\nimport './App.css'\nimport Gifs from './Gifs'\n\ninterface Props {\n  search: (q: string) => void\n}\n\nexport function App({ search }: Props) {\n  const [query, setQuery] = useState('')\n\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\n    setQuery(event.target.value)\n  }\n\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    search(query)\n    event.preventDefault()\n  }\n\n  return (\n    <div className=\"app container\">\n      <nav className=\"header\">\n        <div className=\"header-content container\">\n          <form onSubmit={handleSubmit}>\n            <input\n              type=\"text\"\n              placeholder=\"Search for GIFs\"\n              value={query}\n              onChange={handleInputChange}\n            />\n          </form>\n        </div>\n      </nav>\n      <div className=\"main\">\n        <Gifs />\n      </div>\n    </div>\n  )\n}\n\nconst mapDispatchToProps = { search: searchAction }\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(App)\n","import { combineReducers } from 'redux'\nimport { reducer as gifs } from './ducks/gifs'\nimport { reducer as search } from './ducks/search'\nimport { RootAction, RootState } from './index'\n\nexport const reducers = {\n  search,\n  gifs\n}\n\nexport const reducer = combineReducers<RootState, RootAction>(reducers)\n","import { applyMiddleware, createStore as reduxCreateStore } from 'redux'\nimport { createLogger } from 'redux-logger'\nimport promise from 'redux-promise-middleware'\nimport thunk from 'redux-thunk'\n\nimport { reducer } from './reducer'\n\nconst logger = createLogger()\n\nconst middleware = [promise, thunk]\n\nif (process.env.NODE_ENV !== 'production') {\n  middleware.push(logger)\n}\n\nexport const createStore = () => reduxCreateStore(reducer, applyMiddleware(...middleware))\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport App from './components/App'\nimport { createStore } from './state/createStore'\n\nconst rootElement = document.getElementById('root')\nconst store = createStore()\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n)\n"],"sourceRoot":""}