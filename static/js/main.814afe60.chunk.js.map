{"version":3,"sources":["../node_modules/@giphy/js-brand/dist sync","giphy.ts","state/ducks/gifs.ts","state/ducks/search.ts","state/ducks/viewer.ts","state/selectors.ts","components/hooks/useClientRect.ts","components/FullscreenViewer.tsx","components/hooks/useBricks.ts","components/hooks/useIntersectionObserver.ts","components/Loader.tsx","components/Gifs.tsx","components/App.tsx","state/reducer.ts","state/createStore.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","gf","GiphyFetch","fetchGifs","dispatch","getState","state","query","search","gifs","offset","type","payload","Promise","a","request","giphy","trending","response","getEmptyState","pendingRequests","UPDATE_QUERY","CLOSE","isLoadingSelector","createSelector","moreGifsSelector","totalCount","undefined","viewGifSelector","viewer","gifIndex","index","target","useRef","useState","rect","setRect","handleResize","useCallback","current","getBoundingClientRect","ref","node","useEffect","window","addEventListener","removeEventListener","mapDispatchToProps","close","connect","gif","useClientRect","document","documentElement","style","overflow","body","overflowY","handler","key","width","original","images","maxWidth","Math","min","height","className","onClick","event","preventDefault","backgroundColor","bricksOptions","dependencies","container","instance","keyRef","Bricks","resize","pack","update","currentSize","getCurrentSize","sizes","reduce","size","option","matchMedia","mq","matches","element","onVisiblilityChange","threshold","rootMargin","observer","IntersectionObserver","entry","isIntersecting","observe","disconnect","loader","fetchGifsAction","openGif","isLoading","moreGifs","props","useBricks","packed","columns","gutter","bricksContainer","gifWidth","floor","loaderContainer","useIntersectionObserver","visible","map","idx","onGifClick","g","stopPropagation","handleGifClick","updateQuery","setQuery","onSubmit","placeholder","value","onChange","reducers","action","data","pagination","gifIds","acc","filter","max","count","total_count","reducer","combineReducers","middleware","createLogger","promise","thunk","rootElement","getElementById","store","reduxCreateStore","applyMiddleware","ReactDOM","render"],"mappings":"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","file":"static/js/main.814afe60.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 60;","import { GiphyFetch } from '@giphy/js-fetch-api'\n\nconst API_KEY = '5yFUiFNdRnPjpeUhzS2T2LGyw1Fi9ClD'\nconst gf = new GiphyFetch(API_KEY)\n\nexport default gf\n","import { GifsResult as GiphyResult } from '@giphy/js-fetch-api'\nimport { IGif } from '@giphy/js-types'\nimport giphy from '../../giphy'\nimport { ThunkDispatch, ThunkGetState, ThunkResult } from '../index'\nimport { RootAction } from '../index'\nimport { UPDATE_QUERY } from './search'\n\n// State\n\nexport interface GifsState {\n  id: number\n  gifs: IGif[]\n  pendingRequests: number\n  offset: number\n  totalCount?: number\n}\n\nexport const updateStateFromGiphyResult =\n  (state: GifsState, result: GiphyResult) => {\n    const { data, pagination } = result\n\n    return {\n      ...state,\n      gifs: [...state.gifs, ...data],\n      offset: pagination.offset + pagination.count,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n// Actions\n\nexport const FETCH = 'gifs/FETCH'\nexport const FETCH_PENDING = 'gifs/FETCH_PENDING'\nexport const FETCH_FUFILLED = 'gifs/FETCH_FULFILLED'\n\ninterface FetchResult {\n  id: number\n  response: GiphyResult\n}\n\nexport interface FetchAction {\n  type: typeof FETCH\n  payload: Promise<FetchResult>\n}\n\nexport interface FetchPendingAction {\n  type: typeof FETCH_PENDING\n}\n\nexport interface FetchFulfilledAction {\n  type: typeof FETCH_FUFILLED\n  payload: FetchResult\n}\n\nexport type GifsAction =\n  | FetchAction\n  | FetchPendingAction\n  | FetchFulfilledAction\n\n// Action Creators\n\nexport const fetchGifs = (): ThunkResult<FetchAction> => {\n  return (dispatch: ThunkDispatch, getState: ThunkGetState) => {\n    const state = getState()\n    const { query } = state.search\n    const { id, offset } = state.gifs\n\n    const payload = new Promise<FetchResult>(async (resolve) => {\n      const request = query === '' ? giphy.trending({ offset }) : giphy.search(query, { offset })\n      const response = await request\n\n      resolve({ id, response })\n    })\n\n    return dispatch({\n      type: FETCH,\n      payload\n    })\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (id: number = 0): GifsState => ({\n  id,\n  gifs: [],\n  pendingRequests: 0,\n  offset: 0\n})\n\nexport const reducer = (\n  state: GifsState = getEmptyState(),\n  action: RootAction\n): GifsState => {\n  if (action.type === FETCH_PENDING) {\n    return {\n      ...state,\n      pendingRequests: state.pendingRequests + 1\n    }\n  }\n\n  if (action.type === FETCH_FUFILLED) {\n    const { id, response } = action.payload\n\n    // Ignore the request if it's from a previous search\n    if (state.id !== id) {\n      return state\n    }\n\n    const { data, pagination } = response\n\n    // This de-dupe method could be made more efficient by storing an ids Map in state\n    const gifIds = state.gifs.reduce(\n      (acc: any, g) => {\n        acc[g.id] = true\n        return acc;\n      },\n    {})\n\n    // Only add gifs that aren't already in state\n    const gifs = [...state.gifs, ...data.filter(g => gifIds[g.id] === undefined)]\n\n    // Account for the possibility that requests come back out-of-order\n    const offset = Math.max(state.offset, pagination.offset + pagination.count)\n\n    return {\n      ...state,\n      gifs,\n      offset,\n      totalCount: pagination.total_count,\n      pendingRequests: state.pendingRequests - 1\n    }\n  }\n\n  if (action.type === UPDATE_QUERY) {\n    return getEmptyState(state.id + 1)\n  }\n\n  return state\n}\n","import { RootAction } from '../'\nimport { ThunkDispatch, ThunkResult } from '../index'\nimport { fetchGifs } from './gifs'\n\n// State\n\nexport interface SearchState {\n  query: string\n}\n\n// Actions\n\nexport const UPDATE_QUERY = 'search/UPDATE_QUERY'\n\nexport interface UpdateQueryAction {\n  type: typeof UPDATE_QUERY\n  payload: {\n    query: string\n  }\n}\n\nexport type SearchAction = UpdateQueryAction\n\n// Action Creators\n\nconst updateQuery = (query: string): UpdateQueryAction => {\n  return {\n    type: UPDATE_QUERY,\n    payload: {\n      query\n    }\n  }\n}\n\nexport const search = (query: string): ThunkResult<void> => {\n  return (dispatch: ThunkDispatch) => {\n    dispatch(updateQuery(query))\n    dispatch(fetchGifs())\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (): SearchState => ({\n  query: ''\n})\n\nexport const reducer = (\n  state: SearchState = getEmptyState(),\n  action: RootAction\n): SearchState => {\n  if (action.type === UPDATE_QUERY) {\n    const { query } = action.payload\n\n    return { query }\n  }\n\n  return state\n}\n","import { RootAction } from '../'\n\n// State\n\nexport interface ViewerState {\n  gifIndex: number | null\n}\n\n// Actions\n\nexport const CLOSE    = 'viewer/CLOSE'\nexport const OPEN_GIF = 'viewer/OPEN_GIF'\n\nexport interface CloseAction {\n  type: typeof CLOSE\n}\n\nexport interface OpenGifAction {\n  type: typeof OPEN_GIF\n  payload: {\n    gifIndex: number\n  }\n}\n\nexport type ViewerAction =\n  | CloseAction\n  | OpenGifAction\n\n// Action Creators\n\nexport const close = (): CloseAction => {\n  return {\n    type: CLOSE\n  }\n}\n\nexport const openGif = (gifIndex: number): OpenGifAction => {\n  return {\n    type: OPEN_GIF,\n    payload: {\n      gifIndex\n    }\n  }\n}\n\n// Reducer\n\nexport const getEmptyState = (): ViewerState => ({\n  gifIndex: null\n})\n\nexport const reducer = (\n  state: ViewerState = getEmptyState(),\n  action: RootAction\n): ViewerState => {\n  if (action.type === CLOSE) {\n    return getEmptyState()\n  }\n\n  if (action.type === OPEN_GIF) {\n    const { gifIndex } = action.payload\n\n    return {\n      gifIndex\n    }\n  }\n\n  return state\n}\n","import { IGif } from '@giphy/js-types'\nimport { createSelector } from 'reselect'\nimport { RootState } from './'\n\nexport const isLoadingSelector = createSelector<RootState, number, boolean>(\n  state => state.gifs.pendingRequests,\n  pendingRequests => pendingRequests > 0\n)\n\nexport const moreGifsSelector = createSelector<RootState, number, number | undefined, boolean>(\n  state => state.gifs.offset,\n  state => state.gifs.totalCount,\n  (offset, totalCount) => totalCount === undefined || offset < totalCount\n)\n\nexport const viewGifSelector = createSelector <RootState, number | null, IGif[], IGif | null>(\n  state => state.viewer.gifIndex,\n  state => state.gifs.gifs,\n  (index, gifs) => index !== null ? gifs[index] : null\n)\n","import { useCallback, useEffect, useRef, useState } from 'react'\n\nexport default (): [ClientRect | null, (node: HTMLElement | null) => void] => {\n  const target = useRef<HTMLElement | null>(null)\n  const [rect, setRect] = useState<ClientRect | null>(null)\n\n  const handleResize = useCallback(() => {\n    if (target.current !== null) {\n      setRect(target.current.getBoundingClientRect())\n    }\n  }, [target])\n\n  const ref = useCallback(node => {\n    if (node !== null) {\n      target.current = node\n      handleResize()\n    }\n  }, [handleResize])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize)\n    return () => {\n      window.removeEventListener('resize', handleResize)\n    }\n  })\n\n  return [rect, ref]\n}\n","import { IGif } from '@giphy/js-types'\nimport { Gif } from '@giphy/react-components'\nimport React, { MouseEvent, useEffect } from 'react'\nimport { connect } from 'react-redux'\nimport { RootState } from '../state'\nimport { close as closeAction } from '../state/ducks/viewer'\nimport { viewGifSelector } from '../state/selectors'\nimport './FullscreenViewer.css'\nimport useClientRect from './hooks/useClientRect'\n\ninterface Props {\n  gif: IGif | null\n  close: () => void\n}\n\nexport function FullscreenViewer({ gif, close }: Props) {\n\n  // We will use the client rectable to determine maximum gif width\n  const [rect, ref] = useClientRect()\n\n  // Prevent scrolling when viewer is open\n  useEffect(() => {\n    document.documentElement.style.overflow = gif !== null ? 'hidden' : null\n    document.body.style.overflowY = gif !== null ? 'scroll' : null\n\n    return () => {\n      document.documentElement.style.overflow = null\n      document.body.style.overflowY = null\n    }\n  }, [gif])\n\n  // Add hotkey for closing with esc\n  useEffect(() => {\n    function handler(e: any) {\n      if (e.key === 'Escape') {\n        close()\n      }\n    }\n\n    window.addEventListener('keydown', handler)\n\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', handler)\n    }\n  }, [close])\n\n  const handleClose = (event: MouseEvent) => {\n    close()\n    event.preventDefault()\n  }\n\n  if (gif === null) {\n    return null\n  }\n\n  let width = 600\n\n  if (rect !== null) {\n    const { original } = gif.images\n    // Don't warp the gif more than 2x\n    const maxWidth = Math.min(original.width * 2, rect.width)\n\n    // Fit using a \"contain\" model, maximizing the size while keep both the height and\n    // width in bounds.\n    if (original.height / original.width * maxWidth > rect.height) {\n      width = rect.height * original.width / original.height\n    } else {\n      width = maxWidth\n    }\n  }\n\n  return (\n    <div className=\"fullscreen-viewer\" onClick={handleClose}>\n      <div ref={ref} className=\"fullscreen-viewer-content\">\n        <Gif\n          gif={gif}\n          width={width}\n          backgroundColor=\"black\"\n        />\n      </div>\n    </div>\n  )\n}\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    gif: viewGifSelector(state)\n  }\n}\n\nconst mapDispatchToProps = {\n  close: closeAction\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(FullscreenViewer)\n","import Bricks, { BricksInstance, BricksOptions, SizeDetail } from 'bricks.js'\nimport { RefObject, useEffect, useRef } from 'react'\n\nexport default (\n  bricksOptions: Omit<BricksOptions, 'container'>,\n  key: string = '',\n  dependencies: any[] = []\n): {\n  ref: RefObject<HTMLDivElement>,\n  currentSize: SizeDetail\n} => {\n  const container = useRef<HTMLDivElement | null>(null)\n  const instance = useRef<BricksInstance | null>(null)\n  const keyRef = useRef<string>(key)\n\n  useEffect(\n    () => {\n\n      // A new Bricks.js will be instantiated when one doesn't exist or the key changes.\n      if (container.current !== null && (instance.current === null || keyRef.current !== key)) {\n        instance.current = Bricks({\n          ...bricksOptions,\n          container: container.current,\n        })\n\n        instance.current\n          .resize(true)\n          .pack()\n\n        keyRef.current = key\n      }\n\n      if (instance.current !== null) {\n        // At this point we are calling the more efficient update with the assumption that\n        // already packed gifs haven't been removed or modified\n        instance.current.update()\n      }\n    },\n\n    // Disable linting to support additional dependencies. Note: brickOptions aren't\n    // included and thus can't be dynamically set.\n    // eslint-disable-next-line\n    [container, ...dependencies]\n  )\n\n  return { ref: container, currentSize: getCurrentSize(bricksOptions.sizes) }\n}\n\n/*\n * Helper function to help us dynamically size our gifs based on the current window size\n * and number of columns and gutter widths currently being used. Currently relies on sizes\n * being ordered from smallest to largest media query, with default as the first element.\n */\nfunction getCurrentSize(sizes: SizeDetail[]): { gutter: number, columns: number} {\n  return sizes.reduce(\n    (size, option) => {\n      return window.matchMedia(`(min-width: ${option.mq})`).matches ? option : size\n    }\n  )\n}\n","import { useEffect } from 'react'\n\nexport interface UseObserverOptions {\n  element: HTMLDivElement | null\n  onVisiblilityChange: (isVisible: boolean) => void,\n  threshold?: number,\n  rootMargin?: string\n}\n\nexport default ({\n  element,\n  onVisiblilityChange,\n  threshold = 0,\n  rootMargin = '0px'\n}: UseObserverOptions) => {\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]: IntersectionObserverEntry[]) => {\n      onVisiblilityChange(entry.isIntersecting)\n    }, { threshold, rootMargin })\n\n    if (element !== null) {\n      observer.observe(element)\n    }\n\n    return () => {\n      if (element !== null) {\n        observer.disconnect()\n      }\n    }\n  })\n}\n","import React from 'react'\nimport './Loader.css'\n\nconst loader = () =>\n  <div className=\"lds-ellipsis\">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n  </div>\n\nexport default loader\n","import { IGif } from '@giphy/js-types'\nimport { Gif } from '@giphy/react-components'\nimport React, { SyntheticEvent, useRef } from 'react'\nimport { connect } from 'react-redux'\nimport { RootState } from '../state'\nimport { fetchGifs as fetchGifsAction } from '../state/ducks/gifs'\nimport { openGif as openGifAction } from '../state/ducks/viewer'\nimport { isLoadingSelector, moreGifsSelector } from '../state/selectors'\nimport './Gifs.css'\nimport { useBricks, useClientRect, useIntersectionObserver } from './hooks'\nimport Loader from './Loader'\n\ninterface Props {\n  query: string\n  gifs: IGif[]\n  isLoading: boolean\n  moreGifs: boolean\n  fetchGifs: () => void\n  openGif: (idx: number) => void\n}\n\nfunction Gifs(props: Props) {\n  const { query, gifs, isLoading, moreGifs, fetchGifs, openGif } = props\n\n  const handleGifClick = (idx: number, event: SyntheticEvent<HTMLElement, Event>) => {\n    openGif(idx)\n    event.stopPropagation()\n    event.preventDefault()\n  }\n\n  // This ref will hold the DOM node of the gif container for use by Bricks.js\n  const { ref: bricksContainer, currentSize: { gutter, columns } } = useBricks(\n    {\n      packed: 'packed',\n      sizes: [\n        { columns: 2, gutter: 8 },\n        { mq: '768px', columns: 3, gutter: 12 },\n        { mq: '1024px', columns: 4, gutter: 16 },\n        { mq: '1260px', columns: 4, gutter: 16 }\n      ]\n    },\n    query,\n    [gifs]\n  )\n\n  // useEffect(() => {\n  //   console.log('effect ran')\n  // }, [bricksOptions.current])\n\n  // Calculate the width each gif should be based on the width of the container and the\n  // number of columns and gutter width at the current viewport size\n  let gifWidth = 200\n  const [rect, ref] = useClientRect()\n\n  if (rect !== null) {\n    gifWidth = Math.floor((rect.width - gutter * (columns - 1)) / columns)\n  }\n\n  // Setup observed div at the end of gifs to detect when we should attempt to load\n  // the next page\n  const loaderContainer = useRef<HTMLDivElement>(null)\n\n  const handleVisibilityChange = (visible: boolean) => {\n    if (visible && !isLoading && moreGifs) {\n      fetchGifs()\n    }\n  }\n\n  useIntersectionObserver({\n    element: loaderContainer.current,\n    onVisiblilityChange: handleVisibilityChange,\n    rootMargin: '200px'\n  })\n\n  return (\n    <div ref={ref}>\n      <div ref={bricksContainer} key={query}>\n        { gifs.map(\n            (gif, idx) =>\n              <Gif\n                key={gif.id}\n                gif={gif}\n                width={gifWidth}\n                backgroundColor=\"#e8f4fd\"\n                onGifClick={(g, e) => handleGifClick(idx, e)}\n              />\n        )}\n      </div>\n\n      { moreGifs &&\n        <div ref={loaderContainer} className=\"loader-container\">\n          { isLoading && <Loader /> }\n        </div>\n      }\n    </div>\n  )\n}\n\nconst mapStateToProps = (state: RootState) => {\n  return {\n    query: state.search.query,\n    gifs: state.gifs.gifs,\n    isLoading: isLoadingSelector(state),\n    moreGifs: moreGifsSelector(state)\n  }\n}\n\nconst mapDispatchToProps = {\n  fetchGifs: fetchGifsAction,\n  openGif: openGifAction\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Gifs)\n","import React, { useState } from 'react'\nimport { connect } from 'react-redux'\nimport { search as searchAction } from '../state/ducks/search'\nimport './App.css'\nimport FullscreenViewer from './FullscreenViewer'\nimport Gifs from './Gifs'\n\ninterface Props {\n  search: (q: string) => void\n}\n\nexport function App({ search }: Props) {\n  const [query, setQuery] = useState('')\n\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\n    setQuery(event.target.value)\n  }\n\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    search(query)\n    event.preventDefault()\n  }\n\n  return (\n    <div className=\"app container\">\n      <nav className=\"header\">\n        <div className=\"header-content container\">\n          <form onSubmit={handleSubmit}>\n            <input\n              type=\"text\"\n              placeholder=\"Search for GIFs\"\n              value={query}\n              onChange={handleInputChange}\n            />\n          </form>\n        </div>\n      </nav>\n      <div className=\"main\">\n        <Gifs />\n        <FullscreenViewer />\n      </div>\n    </div>\n  )\n}\n\nconst mapDispatchToProps = { search: searchAction }\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(App)\n","import { combineReducers } from 'redux'\nimport { reducer as gifs } from './ducks/gifs'\nimport { reducer as search } from './ducks/search'\nimport { reducer as viewer } from './ducks/viewer'\nimport { RootAction, RootState } from './index'\n\nexport const reducers = {\n  search,\n  gifs,\n  viewer\n}\n\nexport const reducer = combineReducers<RootState, RootAction>(reducers)\n","import { applyMiddleware, createStore as reduxCreateStore } from 'redux'\nimport { createLogger } from 'redux-logger'\nimport promise from 'redux-promise-middleware'\nimport thunk from 'redux-thunk'\n\nimport { reducer } from './reducer'\n\nconst logger = createLogger()\n\nconst middleware = [promise, thunk]\n\nif (process.env.NODE_ENV !== 'production') {\n  middleware.push(logger)\n}\n\nexport const createStore = () => reduxCreateStore(reducer, applyMiddleware(...middleware))\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport App from './components/App'\nimport { createStore } from './state/createStore'\n\nconst rootElement = document.getElementById('root')\nconst store = createStore()\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n)\n"],"sourceRoot":""}